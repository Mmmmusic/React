JSX：
      className
      htmlFor 
      dangerouslySetInnerHTML
      {/* */}

React：
      声明式开发(js,jq是命令式开发,大部分都是在操作DOM)
      可以和其他框架并存
      组件化(通过ES6的class继承React.Componet来继承组件,组件首字母大写)
      单向数据流
      视图层框架
      函数式编程

      01 声明式开发：
            减少了大量的DOM操作代码量
      02 框架并存：
            不影响其他框架的使用,比如jq,swiper
      03 组件通信:
            父子通信：
                  父组件通过属性向子组件传值,子组件用this.props.(数据)接收
            子父通信：
                  父组件先向子组件传递一个方法,子组件用this.props.(数据/方法)去调用,间接的来操作父组件的数据/方法
      04 单向数据流：
            父组件可以向子组件传值,但是子组件不能直接去改变这个值,只能单向的去传递,不能修改.目的是为了开发方便,组件多了的话,单个只影响单个数据,不会影响其它组件,方便了代码调试
      05 视图层框架：
            用react搭建视图,大型项目需要借用其它数据框架,方便组件通信,小型项目可以使用内置组件通信,大型项目使用redux等数据框架进行数据传递会更为方便,也不会造成代码的冗余
      06 函数式编程：
            用react写出来的项目更容易实现前端自动化测试

React开发调试工具(React Developer Tools)

参数类型校验及参数默认值(PropTypes & DefaultProps)：
      PropTypes(强校验):接收外部传递的值,限制要求组件传递的值类型
      DefaultProps(默认值):设置组件数据默认值(缺省值)

虚拟DOM:
      01 state 数据
      02 JSX模板
      03 数据 + 模板 结合,生成真实的DOM来显示
      04 当state数据改变,数据 + 模板 结合,生成真实的DOM,替换原始的DOM
      缺陷:
            第一次生成了一个完整的DOM片段
            第二次生成了一个完整的DOM片段
            第二次的DOM替换第一次的DOM,替换全部DOM节点,非常耗性能
      
      改良版DOM优势:
            01 state 数据
            02 JSX模板
            03 数据 + 模板 结合,生成真实的DOM来显示
            04 当state数据改变,数据 + 模板 结合,生成真实的DOM,并不直接替换DOM
            05 新的DOM和原始的DOM 作对比,找差异
            06 找出发生变化的地方
            07 只替换掉DOM节点中发生变化的元素,提升性能
      缺陷:
            性能提升并不明显
      
      React的虚拟DOM：
            01 state数据
            02 JSX模板
            03 数据 + 模板 结合,生成真实的DOM来显示
            04 生成虚拟DOM(虚拟DOM是一个 JS对象,用它来描述真实DOM)
               <div id="list"><span>hello</span></div>
               ['div',{id:'list'},['span',{},'hello']]
            05 state发生变化
            06 数据 + 模板,生成新的虚拟DOM(极大的提升了性能) // 生成的是JS对象
               ['div',{id:'list'},['span',{},'123']]
            07 比较原始虚拟DOM和新的虚拟DOM区别,找到区别是span中的内容(比较的是两个JS对象,也极大的提升了性能)
            08 直接操作DOM,改变span中的内容
      优势:
            减少了对真实DOM的创建以及真实DOM的对比,虚拟DOM创建的是JS对象,对比的也是JS对象
            虚拟DOM本质上是一个JS对象,两个JS对象对比是不怎么耗性能的,比较真实的DOM会很耗性能

组件通信:
      父子通信：
            父组件通过属性向子组件传值,子组件用this.props.(数据)接收
      子父通信：
            父组件先向子组件传递一个方法,子组件用this.props.(数据/方法)去调用,间接的来操作父组件的数据/方法

