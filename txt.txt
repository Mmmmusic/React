JSX：
      className
      htmlFor 
      dangerouslySetInnerHTML
      {/* */}

React：
      声明式开发(js,jq是命令式开发,大部分都是在操作DOM)
      可以和其他框架并存
      组件化(通过ES6的class继承React.Componet来继承组件,组件首字母大写)
      单向数据流
      视图层框架
      函数式编程

      01 声明式开发：
            减少了大量的DOM操作代码量
      02 框架并存：
            不影响其他框架的使用,比如jq,swiper
      03 组件通信:
            父子通信：
                  父组件通过属性向子组件传值,子组件用this.props.(数据)接收
            子父通信：
                  父组件先向子组件传递一个方法,子组件用this.props.(数据/方法)去调用,间接的来操作父组件的数据/方法
      04 单向数据流：
            父组件可以向子组件传值,但是子组件不能直接去改变这个值,只能单向的去传递,不能修改.目的是为了开发方便,组件多了的话,单个只影响单个数据,不会影响其它组件,方便了代码调试
      05 视图层框架：
            用react搭建视图,大型项目需要借用其它数据框架,方便组件通信,小型项目可以使用内置组件通信,大型项目使用redux等数据框架进行数据传递会更为方便,也不会造成代码的冗余
      06 函数式编程：
            用react写出来的项目更容易实现前端自动化测试

React开发调试工具(React Developer Tools)

参数类型校验及参数默认值(PropTypes & DefaultProps)：
      PropTypes(强校验):接收外部传递的值,限制要求组件传递的值类型
      DefaultProps(默认值):设置组件数据默认值(缺省值)

虚拟DOM:
      01 state 数据
      02 JSX模板
      03 数据 + 模板 结合,生成真实的DOM来显示
      04 当state数据改变,数据 + 模板 结合,生成真实的DOM,替换原始的DOM
      缺陷:
            第一次生成了一个完整的DOM片段
            第二次生成了一个完整的DOM片段
            第二次的DOM替换第一次的DOM,替换全部DOM节点,非常耗性能
      
      改良版DOM优势:
            01 state 数据
            02 JSX模板
            03 数据 + 模板 结合,生成真实的DOM来显示
            04 当state数据改变,数据 + 模板 结合,生成真实的DOM,并不直接替换DOM
            05 新的DOM和原始的DOM 作对比,找差异
            06 找出发生变化的地方
            07 只替换掉DOM节点中发生变化的元素,提升性能
      缺陷:
            性能提升并不明显
      
      React的虚拟DOM：
            01 state数据
            02 JSX模板
            03 生成虚拟DOM(虚拟DOM是一个 JS对象,用它来描述真实DOM)
               <div id="list"><span>hello</span></div>
               ['div',{id:'list'},['span',{},'hello']]
            04 用虚拟DOM的结构生成数据 + 模板 结合,生成真实的DOM来显示
            05 state发生变化
            06 数据 + 模板,生成新的虚拟DOM(极大的提升了性能) // 生成的是JS对象
               ['div',{id:'list'},['span',{},'123']]
            07 比较原始虚拟DOM和新的虚拟DOM区别,找到区别是span中的内容(比较的是两个JS对象,也极大的提升了性能)
            08 直接操作DOM,改变span中的内容
      优势:
            减少了对真实DOM的创建以及真实DOM的对比,虚拟DOM创建的是JS对象,对比的也是JS对象
            虚拟DOM本质上是一个JS对象,两个JS对象对比是不怎么耗性能的,比较真实的DOM会很耗性能
                  01 性能提升
                  02 使得跨端应用得以实现,React Native,原生应用不存在DOM概念,虚拟DOM本质上是一个JS对象,网页和原生应用都可以正常去解析和识别,在原生应用里可以把虚拟DOM转换成原生的组件

虚拟DOM的diff(difference)算法：07步,两个虚拟DOM(JS对象)的对比方式就是 diff算法
            01 数据发生改变时(调用setState时(props || state))回去对比虚拟DOM
            02 this.setState(是异步操作,为的是提升性能)
            03 虚拟DOM树是同层比对,虚拟DOM节点的对应key值最好不要用index做下标,会导致key值不稳定,使用一个稳定的内容作为key才是一个正确的做法,能不用index做key值就不要用它做key值

React中的ref：帮助我们在react中直接获取DOM,可能会遇见其它问题

生命周期:
      01 Mounting:已插入真实的DOM
            componentWillMount 渲染前调用,在客户端也在服务端,此时可以修改组件的state
            componentDidMount  第一次渲染后调用,可用于发送Ajax等请求

      02 Upadting：正在被重新渲染
            componentWillUpdate 接收新props或state后，进行渲染之前调用,此时不允许更新props或state
            componentDidUpdate  完成渲染新的props或state之后调用,此时可以访问DOM元素

      03 Unmounting:已移出真实DOM
            componentWillUnmount 组件被移除之前调用，可以用于做一些清理工作
            
      ** shouldComponentUpadte  使用不当会出现bug
            组件被更新之前,会自动被执行
            重新渲染render()函数时调用的函数,接收两个参数：nextProps和nextState,分别表示下一个props和下个state的值
            当函数返回false,会阻止接下来的render()函数的调用,阻止组件的重新渲染
            返回true时,组件照常渲染,可以用来优化性能
            如果只是调用this.Setstate并未修改其中的值,可以在该生命周期内做一个判断,返回false会阻止接下来的render()函数渲染,避免重复渲染,优化性能
      
      componentWillReceiveProps 
            当一个组件从父组件接收参数
            只要父组件的render函数被重新执行了,子组件的这个生命周期就会被执行
            如果这个组件第一次存在于父组件中,不会执行
            如果这个组件之前存在于父组件中,才会执行



